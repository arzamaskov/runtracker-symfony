name: CD (Deploy)

on:
  push:
    branches:
      - main
#    tags:
#      - "*"
  workflow_dispatch: {}

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/runtracker
  DOCKER_BUILDKIT: "1"

jobs:
  # Запускаем тесты перед сборкой образов
  tests:
    name: Backend Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: app_password
          POSTGRES_DB: runtracker_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U app"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          extensions: pdo, pdo_pgsql, zip, opcache
          coverage: none

      - name: Cache Composer
        uses: actions/cache@v4
        with:
          path: backend/vendor
          key: ${{ runner.os }}-composer-${{ hashFiles('backend/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: Create .env file
        working-directory: backend
        run: |
          cp .env.test .env
          echo "APP_SECRET=test_secret_for_ci" >> .env
          echo "DEFAULT_URI=http://localhost" >> .env
          echo "JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem" >> .env
          echo "JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem" >> .env
          echo "JWT_PASSPHRASE=test" >> .env

      - name: Install Composer dependencies
        working-directory: backend
        run: composer install --no-interaction --no-progress --prefer-dist

      - name: Generate JWT keys for tests
        working-directory: backend
        run: |
          mkdir -p config/jwt
          openssl genpkey -out config/jwt/private.pem -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -pass pass:test
          openssl rsa -in config/jwt/private.pem -outform PEM -pubout -out config/jwt/public.pem -passin pass:test

      - name: Run database migrations
        working-directory: backend
        env:
          APP_ENV: test
          DATABASE_URL: postgresql://app:app_password@localhost:5432/runtracker?serverVersion=16&charset=utf8
        run: php bin/console doctrine:migrations:migrate --no-interaction

      - name: Run tests (PHPUnit)
        working-directory: backend
        env:
          DATABASE_URL: postgresql://app:app_password@localhost:5432/runtracker?serverVersion=16&charset=utf8
        run: vendor/bin/phpunit --configuration phpunit.dist.xml

  build:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [tests]
    timeout-minutes: 30

    env:
      CACHE_APP: ghcr.io/${{ github.repository_owner }}/runtracker:cache-app
      CACHE_WEB: ghcr.io/${{ github.repository_owner }}/runtracker:cache-web

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      # Безопасный тег (на случай специальных символов в git tag)
      - name: Compute SAFE_TAG
        if: startsWith(github.ref, 'refs/tags/')
        id: tag
        shell: bash
        run: |
          RAW="${GITHUB_REF_NAME}"
          SAFE=$(printf "%s" "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g')
          echo "safe=$SAFE" >> "$GITHUB_OUTPUT"
          echo "SAFE_TAG=$SAFE"

      # APP: всегда пушим образ с SHA
      - name: Build & push APP (SHA)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/php/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_APP }}
            type=gha,scope=app
          cache-to: |
            type=registry,ref=${{ env.CACHE_APP }},mode=max,compression=zstd
            type=gha,mode=max,scope=app
          tags: ${{ env.IMAGE_NAME }}:app-${{ github.sha }}

      - name: Verify APP image exists
        run: docker buildx imagetools inspect ${{ env.IMAGE_NAME }}:app-${{ github.sha }}

      # APP: на тегах добавляем version и latest
      - name: Build & push APP (version, latest)
        if: startsWith(github.ref, 'refs/tags/')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/php/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_APP }}
            type=gha,scope=app
          cache-to: |
            type=registry,ref=${{ env.CACHE_APP }},mode=max,compression=zstd
            type=gha,mode=max,scope=app
          tags: |
            ${{ env.IMAGE_NAME }}:app-${{ steps.tag.outputs.safe }}
            ${{ env.IMAGE_NAME }}:app-latest

      # WEB: всегда пушим образ с SHA
      - name: Build & push WEB (SHA)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_WEB }}
            type=gha,scope=web
          cache-to: |
            type=registry,ref=${{ env.CACHE_WEB }},mode=max,compression=zstd
            type=gha,mode=max,scope=web
          tags: ${{ env.IMAGE_NAME }}:web-${{ github.sha }}

      - name: Verify WEB image exists
        run: docker buildx imagetools inspect ${{ env.IMAGE_NAME }}:web-${{ github.sha }}

      # WEB: на тегах добавляем version и latest
      - name: Build & push WEB (version, latest)
        if: startsWith(github.ref, 'refs/tags/')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_WEB }}
            type=gha,scope=web
          cache-to: |
            type=registry,ref=${{ env.CACHE_WEB }},mode=max,compression=zstd
            type=gha,mode=max,scope=web
          tags: |
            ${{ env.IMAGE_NAME }}:web-${{ steps.tag.outputs.safe }}
            ${{ env.IMAGE_NAME }}:web-latest

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    timeout-minutes: 20

    steps:
      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.2.2
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          GITHUB_SHA: ${{ github.sha }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          command_timeout: 20m
          envs: IMAGE_NAME,GITHUB_SHA,GHCR_USERNAME,GHCR_TOKEN
          script: |
            set -euo pipefail
            cd /opt/run-app

            # Login to GHCR
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin

            # Immutable deploy по SHA (не latest!)
            APP_IMAGE="${IMAGE_NAME}:app-${GITHUB_SHA}"
            WEB_IMAGE="${IMAGE_NAME}:web-${GITHUB_SHA}"

            echo "Deploying images:"
            echo "  APP: ${APP_IMAGE}"
            echo "  WEB: ${WEB_IMAGE}"

            # Preflight: проверяем что образы существуют
            docker manifest inspect "${APP_IMAGE}" >/dev/null || { echo "ERROR: Missing ${APP_IMAGE}"; exit 1; }
            docker manifest inspect "${WEB_IMAGE}" >/dev/null || { echo "ERROR: Missing ${WEB_IMAGE}"; exit 1; }

            # Обновляем docker-compose.production.yml с новыми образами
            sed -i "s|IMAGE_APP|${APP_IMAGE}|g" docker-compose.production.yml
            sed -i "s|IMAGE_WEB|${WEB_IMAGE}|g" docker-compose.production.yml

            # Validate compose config
            docker compose -f docker-compose.production.yml config -q

            # Pull новых образов
            docker compose -f docker-compose.production.yml pull

            # Graceful restart
            docker compose -f docker-compose.production.yml down
            docker compose -f docker-compose.production.yml up -d --remove-orphans

            # Подождем пока контейнеры поднимутся
            sleep 5
            
            # Создадим директории кеша с правильными правами в каждом контейнере
            echo "Creating cache directories with proper permissions..."
            for service in app queue scheduler; do
              docker compose -f docker-compose.production.yml exec -T -u root $service sh -c "
                mkdir -p /var/www/backend/var/cache/prod \
                         /var/www/backend/var/cache/dev \
                         /var/www/backend/var/cache/test \
                         /var/www/backend/var/log && \
                chown -R www-data:www-data /var/www/backend/var && \
                chmod -R 775 /var/www/backend/var
              " || true
            done
            
            sleep 5

            # Проверим логи entrypoint для диагностики
            echo "Checking entrypoint logs..."
            echo "=== App logs ==="
            docker compose -f docker-compose.production.yml logs app 2>&1 | tail -50 || true
            echo "=== Queue logs ==="
            docker compose -f docker-compose.production.yml logs queue 2>&1 | tail -50 || true
            echo "=== Scheduler logs ==="
            docker compose -f docker-compose.production.yml logs scheduler 2>&1 | tail -50 || true

            # Проверим статус контейнеров
            echo "Checking container status..."
            docker compose -f docker-compose.production.yml ps || true

            # Проверим права на директории
            echo "Checking directory permissions..."
            docker compose -f docker-compose.production.yml exec -T -u root app sh -c "ls -la /var/www/backend/ || true" || true
            docker compose -f docker-compose.production.yml exec -T -u root app sh -c "test -d /var/www/backend/var && ls -la /var/www/backend/var/ || echo 'var directory does not exist'" || true
            docker compose -f docker-compose.production.yml exec -T -u root app sh -c "test -d /var/www/backend/var/cache && ls -la /var/www/backend/var/cache/ || echo 'cache directory does not exist'" || true
            
            # Проверим, выполняется ли entrypoint
            echo "Checking if entrypoint runs..."
            docker compose -f docker-compose.production.yml exec -T -u root queue sh -c "cat /tmp/entrypoint.log 2>/dev/null || echo 'entrypoint.log does not exist'" || true
            docker compose -f docker-compose.production.yml exec -T -u root queue sh -c "test -f /usr/local/bin/entrypoint.sh && echo 'entrypoint.sh exists' || echo 'entrypoint.sh does not exist'" || true
            docker compose -f docker-compose.production.yml exec -T -u root queue sh -c "ls -la /usr/local/bin/entrypoint.sh || true" || true

            # Run migrations and clear cache
            docker compose -f docker-compose.production.yml exec -T app php bin/console doctrine:migrations:migrate --no-interaction || true
            docker compose -f docker-compose.production.yml exec -T app php bin/console cache:clear --no-warmup
            docker compose -f docker-compose.production.yml exec -T app php bin/console cache:warmup

            # Restart workers для подхвата нового кода
            docker compose -f docker-compose.production.yml restart queue scheduler

            # Cleanup
            docker image prune -f

            # Status check
            docker compose -f docker-compose.production.yml ps

            echo "✅ Deployment completed successfully!"
            echo "   APP: ${APP_IMAGE}"
            echo "   WEB: ${WEB_IMAGE}"
