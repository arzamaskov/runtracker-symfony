name: CD (Deploy)

on:
  push:
    branches:
      - main
#    tags:
#      - "*"
  workflow_dispatch: {}

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/runtracker
  DOCKER_BUILDKIT: "1"

jobs:
  # Запускаем тесты перед сборкой образов
  tests:
    name: Backend Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: app_password
          POSTGRES_DB: runtracker_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U app"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          extensions: pdo, pdo_pgsql, zip, opcache
          coverage: none

      - name: Cache Composer
        uses: actions/cache@v4
        with:
          path: backend/vendor
          key: ${{ runner.os }}-composer-${{ hashFiles('backend/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: Create .env file
        working-directory: backend
        run: |
          cp .env.test .env
          echo "APP_SECRET=test_secret_for_ci" >> .env
          echo "DEFAULT_URI=http://localhost" >> .env
          echo "JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem" >> .env
          echo "JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem" >> .env
          echo "JWT_PASSPHRASE=test" >> .env

      - name: Install Composer dependencies
        working-directory: backend
        run: composer install --no-interaction --no-progress --prefer-dist

      - name: Generate JWT keys for tests
        working-directory: backend
        run: |
          mkdir -p config/jwt
          openssl genpkey -out config/jwt/private.pem -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -pass pass:test
          openssl rsa -in config/jwt/private.pem -outform PEM -pubout -out config/jwt/public.pem -passin pass:test

      - name: Run database migrations
        working-directory: backend
        env:
          APP_ENV: test
          DATABASE_URL: postgresql://app:app_password@localhost:5432/runtracker?serverVersion=16&charset=utf8
        run: php bin/console doctrine:migrations:migrate --no-interaction

      - name: Run tests (PHPUnit)
        working-directory: backend
        env:
          DATABASE_URL: postgresql://app:app_password@localhost:5432/runtracker?serverVersion=16&charset=utf8
        run: vendor/bin/phpunit --configuration phpunit.dist.xml

  build:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [tests]
    timeout-minutes: 30

    env:
      CACHE_APP: ghcr.io/${{ github.repository_owner }}/runtracker:cache-app
      CACHE_WEB: ghcr.io/${{ github.repository_owner }}/runtracker:cache-web

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      # Безопасный тег (на случай специальных символов в git tag)
      - name: Compute SAFE_TAG
        if: startsWith(github.ref, 'refs/tags/')
        id: tag
        shell: bash
        run: |
          RAW="${GITHUB_REF_NAME}"
          SAFE=$(printf "%s" "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g')
          echo "safe=$SAFE" >> "$GITHUB_OUTPUT"
          echo "SAFE_TAG=$SAFE"

      # APP: всегда пушим образ с SHA
      - name: Build & push APP (SHA)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/php/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_APP }}
            type=gha,scope=app
          cache-to: |
            type=registry,ref=${{ env.CACHE_APP }},mode=max,compression=zstd
            type=gha,mode=max,scope=app
          tags: ${{ env.IMAGE_NAME }}:app-${{ github.sha }}

      - name: Verify APP image exists
        run: docker buildx imagetools inspect ${{ env.IMAGE_NAME }}:app-${{ github.sha }}

      # APP: на тегах добавляем version и latest
      - name: Build & push APP (version, latest)
        if: startsWith(github.ref, 'refs/tags/')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/php/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_APP }}
            type=gha,scope=app
          cache-to: |
            type=registry,ref=${{ env.CACHE_APP }},mode=max,compression=zstd
            type=gha,mode=max,scope=app
          tags: |
            ${{ env.IMAGE_NAME }}:app-${{ steps.tag.outputs.safe }}
            ${{ env.IMAGE_NAME }}:app-latest

      # WEB: всегда пушим образ с SHA
      - name: Build & push WEB (SHA)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_WEB }}
            type=gha,scope=web
          cache-to: |
            type=registry,ref=${{ env.CACHE_WEB }},mode=max,compression=zstd
            type=gha,mode=max,scope=web
          tags: ${{ env.IMAGE_NAME }}:web-${{ github.sha }}

      - name: Verify WEB image exists
        run: docker buildx imagetools inspect ${{ env.IMAGE_NAME }}:web-${{ github.sha }}

      # WEB: на тегах добавляем version и latest
      - name: Build & push WEB (version, latest)
        if: startsWith(github.ref, 'refs/tags/')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          cache-from: |
            type=registry,ref=${{ env.CACHE_WEB }}
            type=gha,scope=web
          cache-to: |
            type=registry,ref=${{ env.CACHE_WEB }},mode=max,compression=zstd
            type=gha,mode=max,scope=web
          tags: |
            ${{ env.IMAGE_NAME }}:web-${{ steps.tag.outputs.safe }}
            ${{ env.IMAGE_NAME }}:web-latest

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    timeout-minutes: 20

    steps:
      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.2.2
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          GITHUB_SHA: ${{ github.sha }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          command_timeout: 20m
          envs: IMAGE_NAME,GITHUB_SHA,GHCR_USERNAME,GHCR_TOKEN,GITHUB_REPOSITORY
          script: |
            set -euo pipefail
            cd /opt/run-app

            # Обновляем docker-compose.production.yml из репозитория
            echo "Updating docker-compose.production.yml from repository..."
            curl -fsSL \
              -H "Authorization: token ${GHCR_TOKEN}" \
              -H "Accept: application/vnd.github.v3.raw" \
              -o docker-compose.production.yml.new \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/docker-compose.production.yml?ref=${GITHUB_SHA}" \
              && mv docker-compose.production.yml.new docker-compose.production.yml \
              || echo "⚠️  Failed to download docker-compose.production.yml, using existing file"

            # Проверяем наличие .env файла с переменными окружения
            if [ ! -f .env ]; then
              echo "❌ ERROR: .env file not found in /opt/run-app"
              echo "Please create .env file with required variables:"
              echo "  DB_NAME, DB_USER, DB_PASSWORD"
              echo "  APP_SECRET, JWT_SECRET_KEY, JWT_PUBLIC_KEY, JWT_PASSPHRASE"
              exit 1
            fi

            # Проверяем наличие обязательных переменных
            source .env || true
            if [ -z "${DB_NAME:-}" ] || [ -z "${DB_USER:-}" ] || [ -z "${DB_PASSWORD:-}" ]; then
              echo "❌ ERROR: Missing required database variables in .env:"
              echo "  DB_NAME=${DB_NAME:-NOT SET}"
              echo "  DB_USER=${DB_USER:-NOT SET}"
              echo "  DB_PASSWORD=${DB_PASSWORD:-NOT SET}"
              exit 1
            fi

            # Login to GHCR
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin

            # Immutable deploy по SHA (не latest!)
            APP_IMAGE="${IMAGE_NAME}:app-${GITHUB_SHA}"
            WEB_IMAGE="${IMAGE_NAME}:web-${GITHUB_SHA}"

            echo "Deploying images:"
            echo "  APP: ${APP_IMAGE}"
            echo "  WEB: ${WEB_IMAGE}"

            # Preflight: проверяем что образы существуют
            docker manifest inspect "${APP_IMAGE}" >/dev/null || { echo "ERROR: Missing ${APP_IMAGE}"; exit 1; }
            docker manifest inspect "${WEB_IMAGE}" >/dev/null || { echo "ERROR: Missing ${WEB_IMAGE}"; exit 1; }

            # Обновляем docker-compose.production.yml с новыми образами
            sed -i "s|IMAGE_APP|${APP_IMAGE}|g" docker-compose.production.yml
            sed -i "s|IMAGE_WEB|${WEB_IMAGE}|g" docker-compose.production.yml

            # Validate compose config (с переменными из .env)
            docker compose -f docker-compose.production.yml --env-file .env config -q

            # Pull новых образов
            docker compose -f docker-compose.production.yml --env-file .env pull

            # Graceful restart (с переменными из .env)
            docker compose -f docker-compose.production.yml --env-file .env down
            docker compose -f docker-compose.production.yml --env-file .env up -d

            # Wait for services to be healthy
            echo "Waiting for services to start..."
            sleep 15
            
            # Check postgres status
            echo "Checking postgres status..."
            docker compose -f docker-compose.production.yml --env-file .env ps postgres || true
            
            # Wait for postgres to become healthy (with timeout)
            echo "Waiting for postgres to become healthy..."
            timeout=60
            while [ $timeout -gt 0 ]; do
              status=$(docker compose -f docker-compose.production.yml --env-file .env ps postgres --format json 2>/dev/null | grep -o '"Health":"[^"]*"' | cut -d'"' -f4 || echo "")
              if [ "$status" = "healthy" ]; then
                echo "✅ Postgres is healthy"
                break
              fi
              echo "Waiting for postgres... ($timeout seconds left)"
              sleep 2
              timeout=$((timeout - 2))
            done
            
            if [ $timeout -le 0 ]; then
              echo "⚠️  Postgres healthcheck timeout, showing logs:"
              docker compose -f docker-compose.production.yml --env-file .env logs postgres --tail 50 || true
              echo "Attempting to continue anyway..."
            fi

            # Run migrations and clear cache
            docker compose -f docker-compose.production.yml --env-file .env exec -T app php bin/console doctrine:migrations:migrate --no-interaction || true
            docker compose -f docker-compose.production.yml --env-file .env exec -T app php bin/console cache:clear --no-warmup
            docker compose -f docker-compose.production.yml --env-file .env exec -T app php bin/console cache:warmup

            # Cleanup old images
            docker image prune -f

            echo "✅ Deployment completed successfully!"
            echo "   APP: ${APP_IMAGE}"
            echo "   WEB: ${WEB_IMAGE}"
